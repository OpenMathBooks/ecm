<!DOCTYPE html>
<html lang="en-US">
<!--**************************************-->
<!--*    Generated from PreTeXt source   *-->
<!--*    on 2019-09-28T11:07:13-06:00    *-->
<!--*                                    *-->
<!--*      https://pretextbook.org       *-->
<!--*                                    *-->
<!--**************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body><div class="solution">
<p>This really comes down to how to represent the elements of the set \(X\text{.}\) We represent a lattice path from \((0,0)\) to \((k, n-k)\) as a sequence of <em class="emphasis">R</em>'s and <em class="emphasis">U</em>'s, representing a step to the right or a step up.  Note that this means that each lattice path will be a sequence containing a total of \(n\) symbols, of which \(k\) will be <em class="emphasis">R</em>'s.</p>
<p>Now we can define the bijection.  The function \(f\) takes a string of <em class="emphasis">R</em>'s and <em class="emphasis">U</em>'s, and replaces each <em class="emphasis">R</em> with a 1 and each <em class="emphasis">U</em> with a 0.</p>
<p>To prove this is a bijection, there are four things we need to check:</p>
<ol class="decimal">
<li>That \(f(x)\) is defined for each \(x \in X\) (i.e., every lattice path is sent to some \(n\)-bit string of weight \(k\)).</li>
<li>That \(f(x)\) is <em class="emphasis">uniquely</em> defined for each \(x \in X\) (i.e., no lattice path is sent to more than one bit string).</li>
<li>That every \(y \in Y\) is the image of at least one \(x \in X\) (i.e., that every \(n\)-bit string of weight \(k\) is the output of the function at least once).</li>
<li>That every \(y \in Y\) is the image of at most one \(x \in X\) (i.e., that no \(n\)-bit string of weight \(k\) is the output of the function more than once.)</li>
</ol>
<p>The first two conditions guarantee that \(f\) will be a function.  The third says that \(f\) is onto (a surjection).  The fourth says that \(f\) is one-to-one (an injection).</p>
<p>Let's do this.  First, since elements in \(X\) contain \(k\) <em class="emphasis">R</em>'s and \(n-k\) <em class="emphasis">U</em>'s, applying the rule for \(f\) will result in a bit string containing \(k\) 1's and \(n-k\) 0's, for a total length of \(n\text{.}\)  Thus each element of \(X\) will be sent to an element of \(Y\text{.}\)  Further, it is not possible for an element of \(X\) to be sent to more than one element of \(Y\) since our procedure is well defined.</p>
<p>To show that \(f\) is surjective, consider an arbitrary \(y \in Y\text{.}\)  If we replace each 1 with an <em class="emphasis">R</em> and each 0 with a <em class="emphasis">U</em>, then we get an element \(x \in X\) (because of the length of weight of the strings) and then \(f(x) = y\text{.}\)</p>
<p>Finally, to show that \(f\) is injective, consider \(x_1, x_2 \in X\) and suppose \(x_1 \ne x_2\text{.}\)  Then there is a first position in which they differ (a point on the lattice path where one path goes right and the other goes up).  But then this bit will be different in \(f(x_1)\) and \(f(x_2)\text{.}\)</p>
</div></body>
</html>
